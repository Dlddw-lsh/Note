# 指针

## 指针数组

```c++
int arr1[] = {1, 2, 3, 4, 5};
int arr2[] = {2, 3, 4, 5, 6};
int arr3[] = {3, 4, 5, 6, 7};
//创建指针数组
int *parr[] = {arr1, arr2, arr3};//主语是数组，里面的变量为指针
//访问
for (int i = 0; i < 3; i++)
{
    for (int j = 0; j < 3; j++)
    {
        cout << *(parr[i] + j) << " "
    }
    cout << endl;
}
```

## 数组指针

- 数组指针是指向一个数组的指针

```c++
int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
int (*p)[10] = &arr;//创建数组指针并初始化为arr的地址

char* arr[5];//指针数组
char* (*pa)[5] = &arr;//&arr表示数组的地址，将其放到数组指针中

int arr[5];//数组
int *parr1[10];//[]优先级高于*所以parr1为数组，有10个元素，每个元素的类型为int* parr1为指针数组
int (*parr2)[10];//parr2是一个指针，指向了一个数组，每个数组有10个元素，每个元素的类型为int，parr2为数组指针
int (*parr3[10])[5];//parr3是一个数组，该数组有10个元素，每个元素是一个数组指针，该数组指针指向的元素有5个元素，每个元素是int类型
```

## 一维数组传参

```c++
int arr[10] = {0};
int *arr2[20] = {0};
void test(int arr[]);//ok
void test(int arr[10]); //ok
void test(int *arr);//ok
void test2(int *arr[20]);//ok
void test2(int **arr);//ok
```

## 二维数组传参

````c++
int arr[3][5] = {0};
//数组形式
void test(int arr[3][5]);//ok
void test1(int arr[][5]);//ok
void test2(int arr[3][]);//错误不能省略列

//指针形式
void test(int **arr);//err
void test(int (*arr)[5]);//ok

//二级指针传参
void test(int **p);
int *ptr;
int **pp = &ptr;
test(pp);
test(&ptr);
int *arr[10];//指针数组，数组中有10个元素，每个元素都为指针
test(arr);//arr为首元素的地址，因为首元素是指针，所以指针的地址可以传进去
````

## 函数指针

- 指向函数的指针 - 存放函数地址的一个指针

```c++
int Add(int x, int y){
    return x + y;
}

int main()
{
    int a = 10;
    int b = 20; 

    // cout << Add(a, b) << endl;
    //&函数名和函数名都是函数的地址
    printf("%p\n", Add);
    printf("%p\n", &Add);

    //定义函数指针
    int (*pa)(int, int) = Add;

    //调用
    cout << pa(2, 3) << endl;
    cout << (*pa)(2, 3) << endl;
    return 0;
}
```

```c++
void print(char *str);
void (*p)(char *) = print;
```

### 函数指针的数组

```c++
#include <iostream>
using namespace std;

int Add(int x, int y){
    return x + y;
}
int Sub(int x, int y){
    return x - y;
}
int Mul(int x, int y){
    return x * y;
}
int Div(int x, int y)
{
    return x / y;
}
//回调函数 - 接受函数的地址进行调用被调用的函数成为回调函数
void Calc(int (*pf)(int, int))
{
    int x, y;
    cin >> x >> y;
    pf(x, y);
}
int main()
{
    int a = 10;
    int b = 20; 

    //定义函数指针数组
    int (*pa[4])(int, int) = {Add, Sub, Mul, Div};
    
    for (int i = 0; i < 4; i++)
    {
        cout << pa[i](a, b) << endl;
    }
    return 0;
}
```

### 指向函数指针数组的指针

- 指向**函数指针数组的指针**是一个**指针**，该**指针指向**一个**数组**，**数组的元素**都是**函数指针**

```c++
#include <iostream>
using namespace std;

int Add(int x, int y)
{
    return x + y;
}

int main()
{
    int arr[10] = {0};
    int (*p)[10] = &arr;//取出数组的地址
    int (*pfArr[4])(int, int);//pfArr是一个数组-函数指针的数组
    int (*(*ppfArr)[4])(int, int) = &pfArr;
    //ppfArr是一个数组指针，指针指向的数组有4个元素，每个元素都是函数指针
    
    return 0;
}
```

### void*指针

- 该指针可以接受任意类型的指针

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

struct Stu
{
    char name[20];
    int age;
};

//比较整型
int cmp_int(const void* x, const void* y)
{
    // return  (*(int*)y - *(int*)x);//降序
    return (*(int*)x - *(int*)y);//升序
}

//比较结构体通过年龄
int cmpStuByAge(const void* x, const void* y)
{
    return ((struct Stu*)x)->age - ((struct Stu*)y)->age;
}

//比较结构体通过名字
int cmpStuByName(const void* x, const void* y)
{
    return strcmp((((struct Stu*)x)->name), ((struct Stu*)y)->name);
}

void test01()
{
    int arr[10] = {0, 4, 6, 5, 3, 1, 2, 7, 8, 9};
    int len = sizeof(arr) / sizeof(arr[0]);
    qsort(arr, len, sizeof(arr[0]), cmp_int);
    for (int i = 0; i < 10; i++)
        printf("%d ", arr[i]);
}


void test02()
{
    struct Stu s[3] = {{"ZhangSan", 20}, {"LiSi", 30}, {"WangWu", 10}};
    int len = sizeof(s) / sizeof(s[0]);
    qsort(s, len, sizeof(s[0]), cmpStuByName);

    for (int i = 0; i < 3; i++)
    {
        printf("%s %d\n", s[i].name, s[i].age);
    }
}
int main()
{
    // test01();
    test02();
    return 0;
}
```

## sizeof判断字节

```c
#include <stdio.h>
#include <string.h>

int main()
{
    /*
    数组名是首元素的地址
    1.sizeof(数组名) - 数组名表示整个数
    2.&数组名 - 数组名表示整个数组
    */
    int a[] = {1, 2, 3, 4};//4 * 4 = 16

    printf("%d\n", sizeof(a));          //16 - 计算的总大小
    printf("%d\n", sizeof(a + 0));      //4 - 数组名首元素地址,a+0还是首元素地址，地址的大小就是4
    printf("%d\n", sizeof(*a));         //4 - 数组名表示首元素地址，*a就是首元素
    printf("%d\n", sizeof(a + 1));      //4 - 第二个元素地址
    printf("%d\n", sizeof(a[1]));       //4 - 第二个元素
    printf("%d\n", sizeof(&a));         //4 - 数组的地址， 数组的地址还是地址，地址为4个字节
    printf("%d\n", sizeof(*&a));        //16 - 取出数组的地址，再解引用就还是数组所以为16
    printf("%d\n", sizeof(&a + 1));     //4 - &a取出数组的地址再+1跳过整个数组，但还是一个地址
    printf("%d\n", sizeof(&a[0]));      //4 - 首元素的地址4个字节
    printf("%d\n", sizeof(&a[0] + 1));  //4 - 取出第一个元素的地址+1是第二个元素的地址还是4个字节
    
    //字符地址
    char arr[] = {'a', 'b', 'c', 'd', 'e', 'f'};
    printf("%d\n", sizeof(arr));//sizeof计算的是数组大小，6 * 1 = 6字节
    printf("%d\n", sizeof(arr + 0));//4 arr为首元素地址，加0还是地址 地址的大小就是四个字节
    printf("%d\n", sizeof(*arr));//1 arr是首元素地址，首元素是一个字节
    printf("%d\n", sizeof(arr[1]));//1
    printf("%d\n", sizeof(&arr));//4 &arr虽然是数组的地址，但还是地址，地址大小就是4个字节
    printf("%d\n", sizeof(&arr + 1));//4 &arr虽然是数组的地址，+1还是地址，地址大小就是4个字节
    printf("%d\n", sizeof(&arr[0] + 1));//4 地址就是4
    
    printf("%d\n", strlen(arr));//随机值
 	printf("%d\n", strlen(arr + 0));//随机值
    //printf("%d\n", strlen(*arr));//报错
    //printf("%d\n", strlen(arr[1]));//报错
    printf("%d\n", strlen(&arr));//随机值
    printf("%d\n", strlen(&arr + 1));//随机值 - 6就abcdef这六个
    printf("%d\n", strlen(&arr[0] + 1));//随机值 - 1就a这一个
    return 0;
}
```

