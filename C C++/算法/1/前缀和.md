# 一维前缀和和一维差分

## 定义

给定数字数组**num[5] = {1, 3, 7, 5, 2}**,则前缀和数组为**sum[5] = {1, 4, 11, 16, 18}**

​		有如下定义:

$$
sum[i]=\begin{cases}num[0] & i=0\\
sum[i-1]+num[i] & i>1\\
\end{cases}
$$


## 区间和

​	**num[5] = {1, 3, 7, 5, 2}**

​	**sum[5] = {1, 4, 11, 16, 18}**

​	**sum**数组的第**i**项就是**num**数组从第**0**项加到**i**项。**sum[4]**就是**num[0] + num[1] + ... + num[4**]的值为18

​	刚好对应**sum[4]**，而区间和就是，比如要算**2-4**之间的区间和，那么就是**7 + 5 + 2**为**14**刚好是**sum[4] -** 

​	**sum[2 - 1]**的值所以一维区间和的代码如下

 ```c
 #define get_sum(L, R) (L?sum[R] - sum[L - 1] : sum[R])
 int get_sum(int L, int R)//函数形式
 {    
 	if (L != 0)
       return sum[R] - sum[L - 1];
   	else
       return sum[R];
 }
 ```

## 代码实现(C) 

```c
#include <stdio.h>
#define get_sum(L, R) (L?sum[R] - sum[L - 1] : sum[R])
int sum[1001] = {0};

int main()
{
    int num[1001] = {1, 3, 7, 5, 2};
    sum[0] = num[0];
    for (int i = 1; i < 5; i++)
        sum[i] = sum[i - 1] + num[i];
    printf("%d", get_sum(0, 4));//求0-4的区间和
    return 0;
}
```

## 一维差分

现在给定**5**个数字**1 3 7 5 2**如果要进行操作，不如**[2,4]+5**（就是2到4这个区间所有的数字加上5），[**1,3]+2,[0,2]-3**这样，一般思路是给每一个加上5在加上2在减去3

|             | **1** | **3** | **7** | **5** | **2** |
| :---------- | ----- | ----- | ----- | ----- | ----- |
| **[2,4]+5** | 1     | 3     | 12    | 10    | 7     |
| **[1,3]+2** | 1     | 5     | 14    | 12    | 7     |
| **[0,2]-3** | -2    | 2     | 11    | 12    | 7     |

这是三个操作，且只有5个数，如果说是n个数字，m次操作的，那么在这样进行操作无疑是非常麻烦的，所以

这里要引入差分的概念

### 定义

给定任意数组num[n],则差分数组d定义如下
$$
d[i]=\begin{cases}num[0] & i=0\\
num[i]-num[i-1] & i>1\\
\end{cases}
$$

### **用差分对区间进行操作**

下面是数组和差分已经差分的前缀和

| num       | **1** | **3** | **7** | **5** | **2** |
| :-------- | ----- | ----- | ----- | ----- | ----- |
| **d**     | 1     | 2     | 4     | -2    | -3    |
| **sum_d** | 1     | 3     | 7     | 5     | 2     |

则不难发现当**i**不为**0**是**num[i] = sum_d[i-1]+d[i]** ,那么如何利用这个来进行我们上述的操作呢

首先还是上述的数组

| 原数组num   | 1      | 3     | 7     | 5     | 2      |      |
| :---------- | ------ | ----- | ----- | ----- | ------ | ---- |
| d           | 1      | 2     | 4     | -2    | -3     |      |
| **[2,4]+5** | 1      | 3     | 12    | 10    | 7      |      |
| d           | 1      | 2     | **9** | -2    | -3     |      |
| **[1,3]+2** | 1      | 5     | 14    | 12    | 7      |      |
| d           | 1      | **4** | 9     | -2    | **-5** |      |
| **[0,2]-3** | -2     | 2     | 11    | 12    | 7      |      |
| d           | **-2** | 4     | 9     | **1** | -5     |      |

这是将上述个个操作后的数字后的数组，用差分表示之后，注意加黑的差分，在对比前面的区间操作不难看出对于任意的区间**[L,R]+value <==> d[L]+value, d[R+1]-value**(差分标记)，再结合上面的**num[i] = sum_d[i-1]+d[i]**就可以实现对数组区间的修改和操作。

### 代码实现(C)

```c
//一维差分
#include <stdio.h>
#include <stdlib.h>

int d[100] = {0};//差分数组，记得开大点，初始化为0
void add(int l, int r, int v)
{
    d[l] += v;
    d[r + 1] -= v;
}

int main()
{
    int num[100] = {1, 3, 7, 5, 2};
    int sum_d[100] = {0};
    d[0] = num[0];
    for (int i = 1; i < 5; i++)
        d[i] = num[i] - num[i - 1];//计算差分
    add(2, 4, 5);
    add(1, 3, 2);
    add(0, 2, -3);
    sum_d[0] = d[0];
    for (int i = 1; i < 5; i++)
        sum_d[i] = sum_d[i - 1] + d[i];//计算差分的前缀和
    for (int i = 0; i < 5; i++)
        printf("%d ", sum_d[i]); 
    return 0;
}
```

```c
//一维差分（映射方法）
#include <stdio.h>
#include <stdlib.h>

int d[100] = {0};//差分数组，记得开大点，初始化为0
void add(int l, int r, int v)
{
    d[l] += v;
    d[r + 1] -= v;
}

int main()
{
    int num[100] = {1, 3, 7, 5, 2};
    add(2, 4, 5);
    add(1, 3, 2);
    add(0, 2, -3);
    for (int i = 1; i < 5; i++)
        d[i] += d[i - 1];
    for (int i = 0; i < 5; i++)
    {
        num[i] += d[i];//映射回去
        printf("%d ", num[i]);
    }
    return 0;
}
```



# 二维前缀和和二维差分

## 定义

```c
sum[i][j]就是从num[0][0]到num[i]对[j]角线之间的所有数字之和
```

## 前缀和

| num     | j-1  | j     |      |
| ------- | ---- | ----- | ---- |
| **i-1** | 1    | 1     | 1    |
| **i**   | 1    | **2** | 1    |
|         | 1    | 1     | 1    |

比如这里要算[i,j]的前缀和有
$$
sum[i][j]=num[i][j]+sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1]
$$
这里注意几种特殊情况**i=j=0, i=0, j=0**:
$$
sum[i][j]=\begin{cases}
num[0][0]&i=0,j=0\\
num[0][j]+sum[0][j-1]&i=0\\
num[i][0]+sum[i-1][0]&j=0\\
\end{cases}
$$


## 区间和

| num    |      | y1    |       | y2    |      |
| ------ | ---- | ----- | ----- | ----- | ---- |
|        | 1    | 1     | 1     | 1     | 1    |
| **x1** | 1    | **2** | **2** | **2** | 1    |
|        | 1    | **2** | **2** | **2** | 1    |
| **x2** | 1    | **2** | **2** | **2** | 1    |
|        | 1    | 1     | 1     | 1     | 1    |

比如这里要算中间是2代表的着一块的数字的和的话给出以下公式(类比一维前缀和)：
$$
sum[x_1,y_1][x_2,y_2]=sum[x_2][y_2]-sum[x_2][y_1-1]-sum[x_1-1][y_2]+sum[x_1-1][y_1-1]
$$
当出现边界情况是类似于一维前缀和比如:
$$
sum[x_1,y_1][x_2,y_2]=\begin{cases}
sum[x_2][y_2]&x_1=0,y_1=0\\
sum[x_2][y_2]-sum[x_2][y_1-1]&x_1=0\\
sum[x_2][y_2]-sum[x_1-1][y_2]&y_1=0
\end{cases}
$$

## 代码实现(C)

```c
//二维前缀和
#include <stdio.h>
const int n = 3, m = 4;
int num[100][100] = { {1, 5, 6, 8},
                  	  {9, 6, 7, 3},
                      {5, 3, 2, 4} };
int sum[100][100];
void pre_sum()//预处理前缀和
{
    sum[0][0] = num[0][0];//第一个
    for (int i = 1; i < n; i++)//第一列
        sum[i][0] = sum[i - 1][0] + num[i][0];
    for (int j = 1; j < m; j++)//第一行
        sum[0][j] = sum[0][j - 1] + num[0][j];
    for (int i = 1; i < n; i++)
        for (int j = 1; j < m; j++)
            sum[i][j] = num[i][j] + sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];
}

int get_sum(int x1, int y1, int x2, int y2)//处理区间和
{
    if(x1 == 0 && y1 == 0)//左上角为00直接返回定义
        return sum[x2][y2];
    if (x1 == 0)//左上角行为0  抽象为多行的一维的前缀和
        return sum[x2][y2] - sum[x2][y1 - 1];
    if (y1 == 0)//左上角的列为0  抽象为多列的一维的前缀和
        return sum[x2][y2] - sum[x1 - 1][y2];
    return sum[x2][y2] - sum[x2][y1 - 1] - sum[x1 - 1][y2] + sum[x1 - 1][y1 - 1];
}
int main()
{
    pre_sum();
    printf("%d %d", get_sum(1, 1, 2, 2), get_sum(0, 1, 1, 3));
    return 0;
}
```

## 二维差分

![image-20211114201039037](D:\C笔记\images\前缀和\1.png)

比如这里要在蓝色区域加上1那么从x1,y1一直到后面的所有区域都会被加上1如下图

![iamge](D:\C笔记\images\前缀和\2.png)

所以根据上文讲的前缀和可知只需在x1,y2+1和x2+1,y1处各减去1就变成下图

![iamge](D:\C笔记\images\前缀和\3.png)

绿色部分多减了一次1所以要在x2+1,y2+1出在加一次1就变成了

![iamge](D:\C笔记\images\前缀和\4.png)

所以该二维差分给出一下函数

```c
void add(int x1, int y1, int x2, int y2, int v)
{
    d[x1][y1] += v;
    d[x1][y2 + 1] -= v;
    d[x2 + 1][y2] -= v;
    d[x2 + 1][y2 + 1] += v;
}
```

现给出

```c
int num[100][100] = { {1, 5, 6, 8},
                  	  {9, 6, 7, 3},
                      {5, 3, 2, 4} };
```

对该二维数组进行(0,0)到(2,1)区间加3和(1,1)到(2,2)区间-1的操作。

代码实现如下

```c
#include <stdio.h>
const int n = 3, m = 4;
int num[100][100] = { {1, 5, 6, 8},
                      {9, 6, 7, 3},
                      {5, 3, 2, 4} };
int d[100][100] = {0};
int sum[100][100] = {0};

void pre_sum()//预处理区间和
{
    sum[0][0] = d[0][0];//第一个
    for (int i = 1; i < n; i++)//第一行
        sum[i][0] = sum[i - 1][0] + d[i][0];
    for (int j = 1; j < m; j++)//第一列
        sum[0][j] = sum[0][j - 1] + d[0][j];
    for (int i = 1; i < n; i++)
        for (int j = 1; j < m; j++)
            sum[i][j] = d[i][j] + sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1];
    for (int i = 0; i < n; i++)//映射回原数组
        for (int j = 0; j < m; j++)
            num[i][j] += sum[i][j];
}

void add(int x1, int y1, int x2, int y2, int v)//处理区间和
{
    d[x1][y1] += v;
    d[x1][y2 + 1] -= v;
    d[x2 + 1][y2] -= v;
    d[x2 + 1][y2 + 1] += v;
}

void print()//打印
{
    for (int i = 0; i < n; i++)
    {
        for (int j = 0; j < m; j++)
            printf("%d ", num[i][j]);
        printf("\n");
    }
    
}

int main()
{
    add(0, 0, 2, 1, 3);
    add(1, 1, 2, 2, -1);
    pre_sum();
    print();
    return 0;
}
```



