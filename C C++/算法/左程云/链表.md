# 哈希表

### unordered_map与map

- unordered_map底层逻辑为哈希表，无序查找速度快。
- map底层红黑树，有序

### unordered_set与set

- unordered_set无序
- set有序

放入有序表中的内容，如果时基础类型，内部按值传递，如果不是基础类型，必须提供**比较器**。

# 链表

```c++
#include <iostream>
#include <stdlib.h>
using namespace std;
struct Node
{
    int key;
    Node* next;
};

Node* createList();//创建链表
void listInsertByHead(Node* list, int key);//头插
void deleteList(Node* list, int key);//删除节点
void listInsertByTail(Node* list, int key);//尾插
void print(Node* list);//打印链表
void listInsert(Node* list, int pos, int key);//任意位置插入
// Node* listReverse(Node* list);//链表逆序

int main()
{
    Node* list = createList();
    
    
    return 0;
}

Node* createList()
{
    Node* headNode = (Node*)malloc(sizeof(Node));
    if (!headNode)
    {
        printf("Created failed.");
        exit(0);
    }
    headNode->key = 0;
    headNode->next = NULL;
    return headNode;
}

void listInsertByHead(Node* list, int key)
{
    Node* insert = createList();
    insert->key = key;
    insert->next = list->next;
    list->next = insert;
}

void listInsertByTail(Node* list, int key)
{
    Node* insert = createList();
    insert->key = key;
    insert->next = NULL;
    while(list->next != NULL)
        list = list->next;
    list->next = insert;
}

void deleteList(Node* list, int key)
{
    Node* pre;
    while(list->key != key)
    {
        pre = list;        
        list = list->next;
    }
    pre->next = list->next;
    free(list);
}

void print(Node* list)
{
    list = list->next;
    while(list)
    {
        printf("%d ", list->key);
        list = list->next;   
    }
}

void listInsert(Node* list, int pos, int key)
{
    Node* cur = list;
    while(pos--)
    {
        cur = cur->next;
        if (!cur)
        {
            printf("Insert failed.");
            exit(0);
        }
    }
    Node* insert = createList();
    insert->key = key;
    insert->next = cur->next;
    cur->next = insert;
}
```

## 环形链表

[题目]：https://leetcode-cn.com/problems/linked-list-cycle/

改成如果存在返回环形链表的入口，如果不存在返回NULL

- 方法一：使用hash表，每次遍历时在hash表中查是否有此节点，如果有该节点就是环形节点的入口

  - ```c++
    ListNode* hasCycle(ListNode *head) {
        unordered_set<ListNode*> s;
        while(head != nullptr)
        {
            if (s.count(head))
                return head;
            s.insert(head);
            head = head->next;
        }
        return NULL;
    }
    ```

- 方法二：快慢指针，慢指针一次走一步，快指针一次走两步，如果有环那么快慢指针在环中一定会相遇，相遇之后，将快指针放到开头，然后快慢指针每次走一步，当二者相遇时，该节点就是环形节点的入口。

  - ```c++
      ListNode* hasCycle(ListNode *head) {
        if (head == NULL || head->next == NULL)+
            return NULL;
        ListNode* slow = head;
        ListNode* quick = head->next;
        while(slow != quick)
        {
            if (quick == NULL || quick->next == NULL)
                return NULL;
            slow = slow->next;
            quick = quick->next->next;
        }
        quick = head;
        while(quick != slow)
        {
            quick = quick->next;
            slow = slow->next;
        }
        return quick;
    }
    ```

## 链表相交

[题目]：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/

- 方法一：使用hash表先将一条链表存到hash表中，在用第二个链表如果出现相等的那就是相交的

- 方法二：先走一条链表走完记长度为lenA和末节点endA，走另外一条记长度lenB和末节点endB，然后比较endA和endB如果不想等那么不相交，相等之后让长度长的先走二者之差的长，这样二者就在同一起点，在一起走，如果相等那么就时相交链表的起始点。

  - ````c++
    int getListLength(ListNode* head)
    {
        int ans = 0;
        for(; head; head = head->next)
            ans++;
        return ans;
    }
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int lenA = getListLength(headA);
        int lenB = getListLength(headB);
        int len;
        if (lenA > lenB)
        {
            len = lenB;
            while(lenA > lenB)
            {
                headA = headA->next;
                lenA--;
            }
        }
        else
        {
            len = lenA;
            while(lenB > lenA)
            {
                headB = headB->next;
                lenB--;
            }
        }
        while(len--)
        {
            if (headB == headA)
                return headA;
            headA = headA->next;
            headB = headB->next;
        }
        return NULL;
    }
    ````

