# 完全二叉树

- 描述

- 一段从0开始的连续的数组对应

- ![](G:\笔记\C C++\images\左程云\1.png)

  

- **i**的**左孩子**为 **2 * i + 1**，**右孩子**为**2 * i + 2**，**父节点**为**(i-1) >> 1**

## 大根堆

- 大根堆就是该**父节点**比自己的**子节点大**

- **插入**（heapInsert）是heapsize+1然后看自己是否比父节点大如果大就换，一直换到比父小或者到0了就不用换了

- ```c++
  //堆的插入
  void heapInsert(int arr[], int index)
  {
      while(arr[index] > arr[(index - 1) >> 1])
      {
          swap(arr[index], arr[(index - 1) >> 1]);
          index = (index - 1) >> 1;
      }
  
  }
  ```

- 最大值就是根节点

### 删除根节点并堆化(heapify)

- 将**arr[heapsize-1]和arr[0]交换**，然后在0的左孩子和有孩子中选择一个**大的**和**自己交换**，一直持续到子节点没有父节点大

- ```c++
  void heapify(int arr[], int index, int heapSize)
  {
      int left = index * 2 + 1;//左孩子的小标
      while(left < heapSize)//下方还有孩子的时候
      {
          //left + 1为右孩子，如果右有孩子并且右孩子的值大于左孩子那么largest为右孩子的下标,否则为左孩子的下标
          int largest = left + 1 < heapSize && arr[left + 1] > arr[left] ? left + 1 : left;
  
          //父和较大的孩子之间，谁的值最大，把下标给largest
          largest = arr[largest] > arr[index] ? largest : index;
  
          if (largest == index)
              break;
          
          swap(arr[largest], arr[index]);
          index = largest;
          left = index * 2 + 1;
      }
  }
  ```

### 堆排序

- 每次插入是实行heapInsert使之成为大根堆，然后每次讲第一个数字（最大值）和最后一个交换并heapSize--，然后再对1位置实施heapify使之重新变成大根堆，然后再进行交换，一直到heapSize == 0就行了

- ```c++
  //堆排序
  void heapSort(int arr[], int heapSize)
  {
      if (heapSize < 2)
          return;
  
      for (int i = 0; i < heapSize; i++)
          heapInsert(arr, i)//;使用堆插入使之成为大根堆
         
      //for (int i = heapSize - 1; i >= 0; i--)
         // heapify(arr, i, heapSize);//这个稍微块一点O(N)
      
      swap(arr[--heapSize], arr[0]);//交换第一个和最后一个值
      while(heapSize > 0)
      {
          heapify(arr, 0, heapSize);
          swap(arr[--heapSize], arr[0]);//从下标0（第一个位置）实施heapify使之重新成为大根堆
      }
  }
  ```

### 例题

- 已知一个几乎有序的数组，几乎有序是指，如果把数组拍好顺序的话，每个元素移动的距离可以不超过k，并且k相对于数组来说比较小。请选择一个合适的排序算法针对这个数据进行排序。

- 分析

  使用一个小根堆，先将前k个数放到小根堆里，然后将该堆的最小值给arr，然后弹出最小值，再将数组的k+1个数放到堆里，再弹出，再放依次进行，所以使用小根堆，也可以使用优先队列

- ```c++
  void sotredArrDistanceLessK(int arr[], int n, int k)
  {
      priority_queue<int, vector<int>, greater<int>> pq;//小根堆(greater<int>)，默认根顶堆(less<int>)
      int index = 0;
      for (; index <= min(n, k); index++)
          pq.push(arr[index]);
  
      int i = 0;
      for (; index < n; i++, index++)
      {
          pq.push(arr[index]);
          arr[i] = pq.top();
          pq.pop();
      }
  
      while(!pq.empty())
      {
          arr[i++] = pq.top();
          pq.pop();
      }
  }
  ```

### 桶排序（基数排序）

- 
